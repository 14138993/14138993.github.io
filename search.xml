<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue中使用ts</title>
      <link href="/2020/06/28/vuePropertyDecorators/"/>
      <url>/2020/06/28/vuePropertyDecorators/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-ts-初次使用"><a href="#vue-ts-初次使用" class="headerlink" title="vue + ts 初次使用"></a>vue + ts 初次使用</h2><p>因公司项目迁移ts，所有最近有在看 vue + ts，目前我们主要是通过 <code>vue-property-decorator</code> 这个 <code>npm</code> 包来使用vue的一些方法和钩子等<br>这个组件依赖于<code>vue-class-component</code>.它具备以下几个属性:</p><ul><li>@Component (继承于vue-class-component)</li><li>@Emit</li><li>@Inject</li><li>@Provice</li><li>@Prop</li><li>@PropSync</li><li>@Watch</li><li>@Model</li><li>@Ref</li><li>Mixins;</li></ul><h3 id="vue-property-decorator-使用"><a href="#vue-property-decorator-使用" class="headerlink" title="vue-property-decorator 使用"></a>vue-property-decorator 使用</h3><p>在我们需要使用的文件的中单独引入,通过按需加载的方式，引用你需要用到的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;Vue, Component&#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">    @Component(&#123;&#125;)</span><br><span class="line">    export default class test extends Vue&#123;</span><br><span class="line">        text: string &#x3D; 1 </span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>⚠️ 关于之前在 <code>data</code> 里定义的变量 现在我们都可以直接使用ts的变量定义即可</p><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p><code>@Component</code> 中我们可以定义vue的很多属性，比如<strong>自定义指令，过滤器，组件这等等</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;Vue, Component&#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">    import test from &#39;.&#x2F;test&#39;</span><br><span class="line">    @Component(&#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            test</span><br><span class="line">        &#125;,</span><br><span class="line">        directives: &#123;</span><br><span class="line">            focus: &#123;</span><br><span class="line">                inserted: function (el) &#123;</span><br><span class="line">                    el.querySelector(&#39;input&#39;).focus()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    export default class test extends Vue&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h3><p>使用 <code>computed</code> 属性 我们可以通过 <code>getter</code> 来定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;Vue, Component&#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">    @Component(&#123;&#125;)</span><br><span class="line">    export default class test extends Vue&#123;</span><br><span class="line">        name: string &#x3D; &#39;jack&#39;</span><br><span class="line">        get test () &#123;</span><br><span class="line">            return &#39;hellow&#39; + this.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="Emit"><a href="#Emit" class="headerlink" title="@Emit"></a>@Emit</h3><p><code>$emit和$on</code> 是Vue事件的触发与监听，在<code>vue-property-decorator</code>我们可以通过 <code>@Emit</code>来使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;Vue, Component, Emit&#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">    @Component(&#123;&#125;)</span><br><span class="line">    export default class test extends Vue&#123;</span><br><span class="line">        @Emit(&#39;emit-change&#39;) &#x2F;&#x2F; 当执行handelChange 方法时，默认内部会 this.$emit(&#39;emit-change&#39;)</span><br><span class="line">        @Emit() &#x2F;&#x2F; 当执行handelChange 方法时，默认内部会 this.$emit(&#39;handel-change&#39;)</span><br><span class="line">        handelChange(str:string):string&#123;</span><br><span class="line">            &#x2F;&#x2F; 返回值会作为参数会传</span><br><span class="line">            return str</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>当<code>@Emit</code> 不传递参数则 <code>emit</code> 触发的函数为当前函数名，传递了参数则以参数名为触发函数，多个<code>@Emit</code>可以一起使用，内部会进行多个触发操作</p><h3 id="Inject-Provice"><a href="#Inject-Provice" class="headerlink" title="@Inject @Provice"></a>@Inject @Provice</h3><p>vue 中 父级可以通过 <code>Provice</code> 将属性暴露， 所有子级可以通过<code>Inject</code>进行引用，在<code>vue-property-decorator</code>，我们可以通过 <code>@Inject @Provice</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;Vue, Component, Inject,Provide&#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">    @Component(&#123;&#125;)</span><br><span class="line">    export default class test extends Vue&#123;</span><br><span class="line">        @Inject()</span><br><span class="line">        foo!: string;</span><br><span class="line">        </span><br><span class="line">        @Inject(&#39;bar&#39;)</span><br><span class="line">        bar!: string;</span><br><span class="line">        </span><br><span class="line">        @Inject(&#123;</span><br><span class="line">            from:&#39;optional&#39;,</span><br><span class="line">            default:&#39;default&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        optional!: string;</span><br><span class="line"></span><br><span class="line">        @Provide()</span><br><span class="line">        foo &#x3D; &#39;foo&#39;</span><br><span class="line">        </span><br><span class="line">        @Provide(&#39;bar&#39;)</span><br><span class="line">        baz &#x3D; &#39;bar&#39;        </span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>@watch</code> 第一个参数为监控的<code>key</code>值， 第二个参数为可选的<code>options</code>配置,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;Vue, Component, Watch&#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">    @Component(&#123;&#125;)</span><br><span class="line">    export default class test extends Vue&#123;</span><br><span class="line">        @Watch(&#39;person&#39;, &#123; immediate: true, deep: true &#125;)</span><br><span class="line">        onPersonChanged1(val: Person, oldVal: Person) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="Prop-PropSync"><a href="#Prop-PropSync" class="headerlink" title="@Prop @PropSync"></a>@Prop @PropSync</h3><p>组件的<code>Props</code>传递在<code>vue-property-decorator</code>中 我们通过<code>@Prop</code> <code>@PropSync</code>来定义，他们的区别在于<code>PropSync</code>定义的 子组件可以修改不过父级需要使用<code>.sync</code>命令符传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;Vue, Component, Prop, PropSync&#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">    @Component(&#123;&#125;)</span><br><span class="line">    export default class test extends Vue&#123;</span><br><span class="line">        @Prop()</span><br><span class="line">        st: string</span><br><span class="line">        @Prop(&#123;default: () &#x3D;&gt; ([])&#125;)</span><br><span class="line">        list: Array&lt;string&gt;</span><br><span class="line">        @PropSync(&#39;name&#39;, &#123; type: String &#125;) syncedName!: string</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="Model"><a href="#Model" class="headerlink" title="@Model"></a>@Model</h3><p>vue 自定义组件中也可以通过使用 <code>v-model</code> 来进行数据双向绑定， 主要还是通过内部自定义事件来达到目的的，在<code>vue-property-decorator</code>中我们需要通过 <code>@Model</code>来定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;Vue, Component, Model&#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">    @Component(&#123;&#125;)</span><br><span class="line">    export default class test extends Vue&#123;</span><br><span class="line">        &#x2F;&#x2F; 定义事件类型， 参数类型</span><br><span class="line">        @Model(&#39;change&#39;, &#123; type: Boolean &#125;) readonly checked!: boolean</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="Ref"><a href="#Ref" class="headerlink" title="@Ref"></a>@Ref</h3><p>在vue中我们调用组件实例 通过<code>this.$refs.xx</code>，使用 ts 我们可以通过 <code>@ref</code>定义后 就可以直接通过 <code>this.xx</code> 来访问定义的组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;Vue, Component, Ref&#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">    import select from &#39;.&#x2F;select&#39;</span><br><span class="line">    @Component(&#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            select</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    export default class test extends Vue&#123;</span><br><span class="line">        @Ref() readonly select!: select</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><p>在 ts 里使用 混入 <code>Mixins</code> 有2种方式，一种是 通过 <code>vue-class-component</code> 实现继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义类 mixins.ts</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import  Component  from &#39;vue-class-component&#39;;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export default class testMixins extends Vue &#123;</span><br><span class="line">    str: string &#x3D; &quot;Hi&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入</span><br><span class="line">import  Component  &#123;mixins&#125;  from &#39;vue-class-component&#39;;</span><br><span class="line">import testMixins from &#39;mixins.ts&#39;;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export class Test extends mixins(testMixins) &#123;</span><br><span class="line">      mounted()&#123;</span><br><span class="line">          console.log(this.str) &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&gt; Hi</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种通过<code>@Component</code>来使用，需要先定义 module <code>vue/types/vue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Vue, Component &#125; from &#39;vue-property-decorator&#39;</span><br><span class="line"></span><br><span class="line">declare module &#39;vue&#x2F;types&#x2F;vue&#39; &#123;</span><br><span class="line">    interface Vue &#123;</span><br><span class="line">        str: string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export default class testMixins extends Vue &#123;</span><br><span class="line">    str: string &#x3D; &#39;Hi&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Vue, Component &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">import testMixins from &#39;mixins&#39;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    mixins: [testMixins]</span><br><span class="line">&#125;)</span><br><span class="line">export default class TestComponent extends Vue&#123;</span><br><span class="line">    created()&#123;</span><br><span class="line">        console.log(this.str) &#x2F;&#x2F; &#x3D;&gt; Hi</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式主要区别在于是否定义了 module <code>vue/type/vue</code> 没有定义的情况下需要使用 <code>extends</code> 来做混入。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm script自动化工作流（进阶篇）</title>
      <link href="/2020/06/26/script1/"/>
      <url>/2020/06/26/script1/</url>
      
        <content type="html"><![CDATA[<h1 id="npm-script自动化工作流（进阶篇）"><a href="#npm-script自动化工作流（进阶篇）" class="headerlink" title="npm script自动化工作流（进阶篇）"></a>npm script自动化工作流（进阶篇）</h1><p>接 <a href="https://www.ileetcode.cn/2019/12/30/script/">npm script自动化工作流（基础篇）</a>后，本篇主要对一些自动化工具，及一些好用的 <code>npm</code> 包分享</p><h2 id="命令自动补全"><a href="#命令自动补全" class="headerlink" title="命令自动补全"></a>命令自动补全</h2><h3 id="npm-run-less"><a href="#npm-run-less" class="headerlink" title="npm run | less"></a>npm run | less</h3><p>npm 本身自带了展示所有命令的功能，当我们使用 <code>npm run</code> 不跟参数时 能够列举出 <code>script</code>中定义的命令进行查看，结合自带的管道操作符 <code>less</code> 命令，我们就能进行一个选项操作</p><p>当我们使用 <code>npm run | less</code> 后会将结果展示，空格翻页，输入 <code>/</code> 后还能进行搜索操作</p><p>这里推荐一个好用的自动完成的工具 <code>npm</code> 包工具 <a href="https://github.com/lukechilds/zsh-better-npm-completion" target="_blank" rel="noopener">zsh-better-npm-completion</a>，效果如下</p><p><img src= "/img/loading.gifs" data-src="https://github.com/lukechilds/zsh-better-npm-completion/raw/master/demo.gif" alt="zsh-better-npm-completion"></p><h2 id="搭配-git-钩子运行"><a href="#搭配-git-钩子运行" class="headerlink" title="搭配 git 钩子运行"></a>搭配 git 钩子运行</h2><h3 id="git-hooks"><a href="#git-hooks" class="headerlink" title="git hooks"></a>git hooks</h3><p>还记得基础篇中提到过 <code>npm script</code> 中的 <code>pre</code> 和 <code>post</code> 钩子吗，而在 <code>git</code> 中 也提供了类似的钩子 <code>pre-commit、pre-push</code> ， 能让我们在comimt,push 前后去运行一些流程</p><p>基础篇中在对项目进行 <code>build</code>代码构建时，需要去检测代码是否符合规范这种，项目团队人数较多，在提交代码上信息会多样，提交信息不够规范，甚至提交过程中比较匆忙，把不符合规范的代码也提交上去了，针对这<strong>2</strong>种情况<br>我们可以利用 钩子在提交前进行代码规范检测及提交信息规范验证，下面进行简单的配置实验：</p><p>安装 <code>git hooks</code> 钩子实现的npm包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; husky &#x3D;&#x3D;&gt; hooks 钩子 lint-staged &#x3D;&#x3D;&gt; 流程化</span><br><span class="line">npm i husky lint-staged -D</span><br></pre></td></tr></table></figure><p>配置 <code>script</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line"> &quot;precommit&quot;: &quot;npm run lint&quot;,</span><br><span class="line"> &quot;lint&quot;: &quot;eslint *.js&quot;</span><br><span class="line">&#125;</span><br><span class="line">&quot;lint-staged&quot;: &#123;</span><br><span class="line">    &quot;*.(js|ts)&quot;: &quot;eslint --fix&quot;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接下来的提交操作中 我们 <code>commit</code> 之前会对我们当次修改的代码进行eslint 修复，修复完毕后会检测结果，如果还出现错误就会中止这次提交操作，在 <code>lint-staged</code> 还可以配置其他的内容，是不是很强大，这样的化 咱们就可以在<br>提交代码的时候针对代码进行一次检测而且是仅针对当此修改的文件，大大提高的检测效率。</p><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><h3 id="在script中经常遇到一些针对环境变量，文件夹等操作，最好去使用能够跨平台的包去做"><a href="#在script中经常遇到一些针对环境变量，文件夹等操作，最好去使用能够跨平台的包去做" class="headerlink" title="在script中经常遇到一些针对环境变量，文件夹等操作，最好去使用能够跨平台的包去做"></a>在script中经常遇到一些针对环境变量，文件夹等操作，最好去使用能够跨平台的包去做</h3><p>推荐几个使用高的场景</p><ol><li>设置环境变量可以使用 <code>cross-env</code></li><li>删除文件等操作可以使用 <code>rimraf</code></li><li>拷贝可以使用 <code>cpr</code></li><li>创建目录 <code>make-dir-cli</code></li></ol><p>还有一些场景可以去社区找找，不得不说 <code>npm</code> 的强大，你想得到的，想不到的都有，合理使用轮子会让工作事半功倍。</p><h2 id="关于-git-commit-信息的验证"><a href="#关于-git-commit-信息的验证" class="headerlink" title="关于 git commit 信息的验证"></a>关于 git commit 信息的验证</h2><h3 id="vcommit-cli"><a href="#vcommit-cli" class="headerlink" title="vcommit-cli"></a>vcommit-cli</h3><p>之前在学习的过程中 针对提交代码所遇到的两个痛点进行了一个整理的处理方式写了 <a href="https://www.npmjs.com/package/vcommit-cli" target="_blank" rel="noopener">vcommit-cli</a> 这个 <code>npm</code> 包，里面将所有需要的依赖安装，及配置等进行了统一配置会在初始化过程中进行一些询问选择操作，最好会在项目提交时候针对代码规范进行修复检测及针对<code>commit message</code> 信息进行检测操作，当然也还有不足的地方后续改进，后面也会针对这个进行一个详细的文章进行探讨，不足之处，<br>吐槽的地方欢迎进行<strong>留言</strong> or <strong>issues</strong></p><p>后续有新的知识会继续补充😊😊</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 高级小技巧</title>
      <link href="/2020/02/22/vueSkill/"/>
      <url>/2020/02/22/vueSkill/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-高级小技巧"><a href="#vue-高级小技巧" class="headerlink" title="vue 高级小技巧"></a>vue 高级小技巧</h1><p>学会这几个花里胡哨但小技巧，显得贼气（z）质(b) 😄😄</p><h2 id="hookEvent"><a href="#hookEvent" class="headerlink" title="hookEvent"></a>hookEvent</h2><hr><p>小例子:<br>vue监听了滚动事件，一般我们都会定义 beforeDestroy 销毁周期中删除，有什么办法在一个函数完成监听操作呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    &#x2F;&#x2F; 监听窗口发生变化</span><br><span class="line">    window.addEventListener(&#39;resize&#39;, this.handleResize)</span><br><span class="line">    &#x2F;&#x2F; 通过hook监听组件销毁钩子函数，并取消监听事件</span><br><span class="line">    this.$once(&#39;hook:beforeDestroy&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">      window.removeEventListener(&#39;resize&#39;, this.handleResize)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleResize() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写在一个函数里，可读性就比较好，换同学修改也不至于忘记啦，再也不怕 <code>code review</code>😁而且hook 不管只能监听自身组件的钩子哟，有时候咱们用到第三方组件，但是第三方组件确没有类似 change 😣这样的事件，那我们也可以通过hook来解决 😄</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &#x2F;&#x2F; 绑定update钩子 触发函数操作</span><br><span class="line">    &lt;bk-select-user @hook:update&#x3D;&#39;selectupdate&#39;&gt;&lt;&#x2F;bk-select-user&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    selectupdate() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 有没有在使用watch时，写过这种写法呢？</span><br><span class="line">export default  &#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">        xxx () &#123;</span><br><span class="line">            this.getDetail()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getDetail() &#123;</span><br><span class="line">            &#x2F;&#x2F; ... 获取接口等等</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">        this.getDetail()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种默认还需要自己去触发一次调用的场景时非常多的，而 <code>watch</code> 提供了 <code>immediate</code> 的配置项，我们只要将他设置为 <code>true</code> 就可以达成上面代码的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default  &#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">        xxx &#123;</span><br><span class="line">            handler: this.getDetail,</span><br><span class="line">            immediate: true &#x2F;&#x2F; 默认触发一次</span><br><span class="line">            deep： true &#x2F;&#x2F; 深度监听</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getDetail() &#123;</span><br><span class="line">            &#x2F;&#x2F; ... 获取接口等等</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>watch 还提供了 <code>deep</code> 是否深度监听的配置 与 <code>immediate</code> 使用一样配置了后 将会进行进行对每个值深度监听，常用于表单项的监控操作</p><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><hr><p>render 是 vue 提供的函数式组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  &#x2F;&#x2F; 配置functional属性指定组件为函数式组件</span><br><span class="line">  functional: true,</span><br><span class="line">  props: &#123;</span><br><span class="line">    text: &#123;</span><br><span class="line">      type: String</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 渲染函数</span><br><span class="line">   * @param &#123;*&#125; h</span><br><span class="line">   * @param &#123;*&#125; context 等于当前组件的上下文 因为函数式组件没有this, props, slots等属性都只能通过context 访问</span><br><span class="line">   *&#x2F;</span><br><span class="line">  render(h, context) &#123;</span><br><span class="line">    const &#123; props &#125; &#x3D; context</span><br><span class="line">    return &#96;&lt;span&gt;$&#123;context.props.text&#125;&lt;&#x2F;span&gt;&#96;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么情况下使用函数组件"><a href="#什么情况下使用函数组件" class="headerlink" title="什么情况下使用函数组件?"></a>什么情况下使用函数组件?</h3><ol><li>因为函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件</li><li>函数式组件结构比较简单，代码结构更清晰</li><li>不使用 components 时可以作为动态组件展示的另一种方式</li></ol><h3 id="函数式组件与普通组件的区别"><a href="#函数式组件与普通组件的区别" class="headerlink" title="函数式组件与普通组件的区别?"></a>函数式组件与普通组件的区别?</h3><ol><li>函数式组件需要在声明组件是指定functional</li><li>数式组件不需要实例化，没有this,上下文通过第二个参数访问</li><li>函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等</li><li>函数式组件不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement</li><li>函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都被解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)</li></ol><h2 id="observable"><a href="#observable" class="headerlink" title="observable"></a>observable</h2><p>在 vue 中使用数据状态管理需要引入 vuex 插件，但 vuex 只适用大型项目，就如它自身官网所说 ‘如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的’, 在 vue <strong>2.6</strong> 版本更新了一个新的 API <code>VUe.observable</code>, 小型项目中可以使用他来实现vuex的功能,使用步骤为：</p><ul><li>与 <code>vuex</code> 类似需要创建 <code>store</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line"></span><br><span class="line">export const store &#x3D; Vue.observable &#x3D; &#123;</span><br><span class="line">    num: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const mutations &#x3D; &#123;</span><br><span class="line">    add () &#123;</span><br><span class="line">        store.num ++</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在组件中使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click&#x3D;&#39;add&#39;&gt;</span><br><span class="line">    &#123;&#123; num &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; store, mutations &#125; from &#39;.&#x2F;store&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    num() &#123;</span><br><span class="line">      return store.num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      add () &#123;</span><br><span class="line">          mutations.add()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><hr><p>后续内容整理中。。。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm script自动化工作流（基础篇）</title>
      <link href="/2019/12/30/script/"/>
      <url>/2019/12/30/script/</url>
      
        <content type="html"><![CDATA[<h1 id="npm-script自动化工作流（基础篇）"><a href="#npm-script自动化工作流（基础篇）" class="headerlink" title="npm script自动化工作流（基础篇）"></a>npm script自动化工作流（基础篇）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先作为一个前端工程师，对npm 肯定不陌生，平常工作中用到的一些工具都会在npm上下载，而所有的npm 插件都会有 <code>package.json</code> 这个文件，文件里会记录整个包的信息，依赖，配置等，而其中script配置项是可以配置一些自动化命令，例如我们常用的在项目中 可能为用到像 <code>npm run dev｜build</code>这种命令，然后会自动化的去实现一些操作，记得初次接触到这个的时候，觉得很强大，经过去仔细了解了下,npm run 实际上是 npm run-script 命令的简写，那么当我们运行 <code>npm run xxx</code>，内部运行流程是这样的：</p><blockquote></blockquote><ol><li>从 package.json 文件中读取 scripts 对象里面的全部配置;</li><li>以传给 npm run 的第一个参数作为键，比如 dev，在 scripts 对象里面获取对应的值作为接下来要执行的命令，如果没找到直接报错;</li><li>在系统默认的 shell 中执行上述命令。</li></ol><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><hr><p>一般我们在取配置一些script 命令的时候，例如给项目增加 eslint 自动检查的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;lint&quot;: &quot;eslint *.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后运行 <code>npm run lint</code> 之后就会取 lint 这句命令自动执行 eslint 进行规则匹配操作。</p><p>有没有好奇过上面的 eslint 命令是从哪里来的？其实，npm 在执行指定 script 之前会把 node_modules/.bin 加到环境变量 $PATH 的前面，这意味着任何内含可执行文件的 npm 依赖都可以在 npm script 中直接调用，换句话说，你不需要在 npm script 中加上可执行文件的完整路径，比如 <code>./node_modules/.bin/eslint **.js</code>。</p><h2 id="项目多个命令如何同时启动？"><a href="#项目多个命令如何同时启动？" class="headerlink" title="项目多个命令如何同时启动？"></a>项目多个命令如何同时启动？</h2><hr><p>对于一个完整的项目来说 一般 script 中命令都是多个的, 比如还有对 css json 单元测试 运行 打包等命令，那比如下面配置对这么多命令难道要一个个去执行吗？ 那也太不自动化了。</p><p>“scripts”: {<br>  “lint:js”: “eslint *.js”,<br>  “lint:css”: “stylelint *.less”,<br>  “build”: “node –max-old-space-size=6144 build/build.js”,<br>  “test”: “mocha tests/“<br>}</p><p>比如我们现在需要在执行 build 命令的之前将代码进行检查并测试，那么我们需要利用 &amp;&amp; 串行的命令来操作，将命令增加为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;lint&quot;: &quot;eslint *.js&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;node --max-old-space-size&#x3D;6144 build&#x2F;build.js&quot;,</span><br><span class="line">  &quot;test&quot;: &quot;mocha tests&#x2F;</span><br><span class="line">  &quot;build:all&quot; &quot;npm run lint &amp;&amp; npm run test &amp;&amp; npm run build&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后直接执行 <code>npm run bulid:all</code> 来自动执行多个命令，需要注意的是，串行执行的时候如果前序命令失败（通常进程退出码非0），后续全部命令都会终止，也就是说在运行命令过程中 任何一条命令结果出错，后续命令都不再执行。</p><h2 id="有串行那有没有并行？"><a href="#有串行那有没有并行？" class="headerlink" title="有串行那有没有并行？"></a>有串行那有没有并行？</h2><hr><p>在严格串行过程中必须保证每一步命令都不出错才能正常运行完，但有时候我们可能只是想要得到某些命令执行的结果，比如我们仅仅需要测试结果和代码规范结果，这时我们需要将串行命令改为并行 <code>&amp;</code> 命令进行改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;lint&quot;: &quot;eslint *.js&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;node --max-old-space-size&#x3D;6144 build&#x2F;build.js&quot;,</span><br><span class="line">  &quot;test&quot;: &quot;mocha tests&#x2F; &amp; npm run lint &amp; wait&quot;</span><br><span class="line">  &quot;build:all&quot; &quot;npm run lint &amp;&amp; npm run test &amp;&amp; npm run build&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后运行 <code>npm run test</code> 命令后 会相继运行 测试及代码检查 而不会因为某个出错终止。</p><p>⚠️ <code>&amp; wait</code>命令跟并行没有直接关系，因为npm 在运行多个异步任务的时候，任何子命令中启动了长时间运行的进程，比如启用了 mocha 的 –watch 配置，可以使用 ctrl + c 来结束进程，如果没加的话，你就没办法直接结束启动到后台的进程。</p><h2 id="除了操作符，有没有更好的方式？"><a href="#除了操作符，有没有更好的方式？" class="headerlink" title="除了操作符，有没有更好的方式？"></a>除了操作符，有没有更好的方式？</h2><hr><p>如果不喜欢用原生的操作符，可以使用npm 插件包 <code>npm-run-all</code> 具体使用方式可以去 <a href="https://www.npmjs.com/package/npm-run-all" target="_blank" rel="noopener">npm</a> 查看</p><h2 id="script-参数"><a href="#script-参数" class="headerlink" title="script 参数"></a>script 参数</h2><hr><p>在我们使用 eslint 规则时，往往需要在检测的时候运行修复操作 而eslint 提供了 fix 命令来将一些能修复的语法修复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;lint&quot;: &quot;eslint --fix --quit *.js &quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>script 参数传递 通过 <code>--xx</code> 来操作 多个参数空格分开</p><h2 id="script-钩子"><a href="#script-钩子" class="headerlink" title="script 钩子"></a>script 钩子</h2><hr><p>npm script 的设计者为命令的执行增加了类似生命周期的机制，具体来说就是 <code>pre</code> 和 <code>post</code> 钩子脚本。这种特性在某些操作前需要做检查、某些操作后需要做清理的情况下非常有用。</p><p>举例来说，运行 <code>npm run test</code> 的时候，分 3 个阶段：</p><ol><li>检查 scripts 对象中是否存在 pretest 命令，如果有，先执行该命令；</li><li>检查是否有 test 命令，有的话运行 test 命令，没有的话报错；</li><li>检查是否存在 posttest 命令，如果有，执行 posttest 命令；</li></ol><p>那么之前我们使用 <code>&amp;&amp;</code> 命令 运行项目对测试，代码规范命令操作，我们可以使用钩子定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;lint&quot;: &quot;eslint *.js&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;node --max-old-space-size&#x3D;6144 build&#x2F;build.js&quot;,</span><br><span class="line">  pretest: &#39;npm run lint&#39;</span><br><span class="line">  &quot;test&quot;: &quot;mocha tests&#x2F;</span><br><span class="line">  posttest: &#39;xx&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在运行 <code>npm run test</code> 时会先将 lint 命令执行 然后执行 test, 而 posttest 命令最后执行 我们可以用 posttest 命令进行将检测结果进行写文件或者生成html展示,<br>posttest 命令信息收集展示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nyc 信息收集展示依赖包</span><br><span class="line">&#x2F;&#x2F; opn-cli 打开命令工具</span><br><span class="line">npm i nyc opn-cli -D</span><br></pre></td></tr></table></figure><p>增加 cover 命令后 运行顺序 <code>npm run cover &gt; npm run precover &gt; npm run test &gt; npm run lint &gt; npm run postcover</code> 执行完毕将会把信息收集并生成 html 自动打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;lint&quot;: &quot;eslint *.js&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;node --max-old-space-size&#x3D;6144 build&#x2F;build.js&quot;,</span><br><span class="line">  pretest: &#39;npm run lint&#39;</span><br><span class="line">  &quot;test&quot;: &quot;mocha tests&#x2F;</span><br><span class="line">  &quot;precover&quot;: &quot;rm -rf coverage&quot;,</span><br><span class="line">  &quot;cover&quot;: &quot;nyc --reporter&#x3D;html npm test&quot;,</span><br><span class="line">  &quot;postcover&quot;: &quot;rm -rf .nyc_output &amp;&amp; open-cli coverage&#x2F;index.html&quot;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ rm rf 命令为linux 下 window 替换为 rimraf</p><hr><p>基础篇到此结束，后续再根据学习进一步更新。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo + github 快速搭建博客</title>
      <link href="/2019/12/29/book/"/>
      <url>/2019/12/29/book/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-github-快速搭建博客"><a href="#hexo-github-快速搭建博客" class="headerlink" title="hexo + github 快速搭建博客"></a>hexo + github 快速搭建博客</h1><p>话不多说，咱们直接进入主题～</p><h2 id="1-新建城池"><a href="#1-新建城池" class="headerlink" title="1.新建城池"></a>1.新建城池</h2><p>既然要给人访问，如果没有存放代码的地方，既不是白日做梦了，首先上 全球最大同性交友网站 <code>github</code> 新建一个仓库，仓库名必须为 <code>&lt;user-name&gt;.github.io</code>, 其中 <code>&lt;user-name&gt;</code> 就是我们github的昵称，<br>注意必须一样，不能自定义，不要问我为什么，问了我也不会说。</p><h2 id="2-手握神器"><a href="#2-手握神器" class="headerlink" title="2.手握神器"></a>2.手握神器</h2><p>打开命令行，输入下面的命令，全局安装神奇 <code>hexo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><h2 id="3-组建大军"><a href="#3-组建大军" class="headerlink" title="3. 组建大军"></a>3. 组建大军</h2><p><code>hexo</code> 神器使用口诀如下 急急如律令，嘿嘿哈。。。sorry sorry 跑题了，口诀如下，所有口诀掐完，紧跟 <code>hexo s</code>，之后在浏览器访问 <code>localhost:4000</code> 神器搭配，手速要快。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &#x2F;&#x2F; 初始化</span><br><span class="line"></span><br><span class="line">hexo s &#x2F;&#x2F; 本地服务启动</span><br></pre></td></tr></table></figure><p>我们的文件夹下的文件,主要关注以下几个文件</p><ul><li>source 里面存放我们的页面和文章 _post 下都是文章，其他则为页面</li><li>themes 里面是我们下载的主题</li><li>public 里面是我们编译后的文件</li><li>_config.yml 全局的一些配置</li></ul><h2 id="4-神器，城池，大军都有，该去收割一波了"><a href="#4-神器，城池，大军都有，该去收割一波了" class="headerlink" title="4.神器，城池，大军都有，该去收割一波了"></a>4.神器，城池，大军都有，该去收割一波了</h2><p>虽然此时咱们只要默认的一篇 <code>Hello World</code>, 也不能阻止我们想做最靓的仔的决心，首先在根目录下 <code>_config.yml</code>找到 <code>deploy</code>字段，然后使用绝技 <code>copy</code> 大法</p><h4 id="注意点，-github-记得这是-SSH-key-免密登陆-就不用手动了，不会的同学下课记得补习。"><a href="#注意点，-github-记得这是-SSH-key-免密登陆-就不用手动了，不会的同学下课记得补习。" class="headerlink" title="注意点， github 记得这是 SSH key 免密登陆 就不用手动了，不会的同学下课记得补习。"></a>注意点， github 记得这是 SSH key 免密登陆 就不用手动了，不会的同学下课记得补习。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;你的仓库地址&gt; # https:&#x2F;&#x2F;github.com&#x2F;byronbyyuan&#x2F;byronbyyuan.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>施展完毕，不过我们需要喝瓶 脉动 补充下体力进行最后的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下载自动提交的 npm 包</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>是时候向世界证明我们的存在了，下面开始公布</p><p>ps: 不想手动敲这么多命令，下方有配置教你怎么偷懒哟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &#x2F;&#x2F; 清除 pubkic</span><br><span class="line"></span><br><span class="line">hexo g &#x2F;&#x2F; 编译</span><br><span class="line"></span><br><span class="line">hexo d &#x2F;&#x2F; 提交</span><br></pre></td></tr></table></figure><h2 id="5-收获成果"><a href="#5-收获成果" class="headerlink" title="5. 收获成果"></a>5. 收获成果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问 https:&#x2F;&#x2F;&lt;user-name&gt;.github.io&#x2F; 查看效果。</span><br></pre></td></tr></table></figure><h3 id="课外知识点"><a href="#课外知识点" class="headerlink" title="课外知识点"></a>课外知识点</h3><ol><li>如何创建新页面，新文章？</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new post xxx(文件名) &#x2F;&#x2F; 创建新文章</span><br><span class="line"></span><br><span class="line">hexo new page xxx(文件名) &#x2F;&#x2F; 创建新页面</span><br></pre></td></tr></table></figure><p>这里提一下 关于tags link categories 这三个页面 需要在对应md文件里增type 这个属性 值就是本身名字 例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: link</span><br><span class="line">type: link</span><br></pre></td></tr></table></figure><ol start="2"><li>更换主题皮肤</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下载主题到themes文件夹下</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;butterfly&#x2F;hexo-theme-butterfly xxx&#x2F;themes</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改 根目录_config.yml 配置</span><br><span class="line">theme: 你的主题名称</span><br></pre></td></tr></table></figure><ol start="3"><li>中文乱码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改 根目录_config.yml 配置</span><br><span class="line">language: zh-CN &#x2F;&#x2F; 改为中文</span><br></pre></td></tr></table></figure><ol start="4"><li>部署优化</li></ol><p>国际惯例，能偷懒的绝不多写一个字母😂, 修改咱们的<code>package.json</code> 在 <code>script</code> 里增加命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;hexo s&quot;, &#x2F;&#x2F; 本地启动</span><br><span class="line">&quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy&quot; &#x2F;&#x2F; 一键部署到github</span><br></pre></td></tr></table></figure><p>到此搭建博客已经完成，但是你可能觉得美中不足</p><h2 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h2><h3 id="个人域名解析到github域名"><a href="#个人域名解析到github域名" class="headerlink" title="个人域名解析到github域名"></a>个人域名解析到github域名</h3><ol><li>上传到github后在根目录创建 <code>CNAME</code> 里面为自己的域名地址</li><li>在域名服务商将域名解析 不会的请百度，这里就不细说了</li></ol><h3 id="主题优化，评论功能等"><a href="#主题优化，评论功能等" class="headerlink" title="主题优化，评论功能等"></a>主题优化，评论功能等</h3><ol><li>直接去hexo 官网挑选喜欢的主题，一般主题都有详细的配置教程，跟着教程做</li><li>我的博客使用的是 <code>butterfly</code> 如果你觉得喜欢，或者觉得功能满足你，不想自己琢磨，可以直接<a href="https://github.com/14138993/book-config.git" target="_blank" rel="noopener">Fork</a> 一键使用</li><li>评论系统 我使用的是 <a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">valine</a>, 如果你是fork我的 需要在 <code>source &gt; _data &gt; butterfly.yml</code> 里 <code>valine</code> 配置你的 <code>appID</code> 和 <code>appKey</code></li></ol><p>谢谢，到此结束</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2019/12/23/webpack/"/>
      <url>/2019/12/23/webpack/</url>
      
        <content type="html"><![CDATA[<p>内容更新中…</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react</title>
      <link href="/2019/12/23/react/"/>
      <url>/2019/12/23/react/</url>
      
        <content type="html"><![CDATA[<p>内容更新中…</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node</title>
      <link href="/2019/12/23/node/"/>
      <url>/2019/12/23/node/</url>
      
        <content type="html"><![CDATA[<p>内容更新中…</p>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
